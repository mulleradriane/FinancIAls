"""fix_category_uniqueness_auto

Revision ID: 9a1b45a8252c
Revises: 19e4f4905296
Create Date: 2026-02-25 23:39:46.437997

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '9a1b45a8252c'
down_revision: Union[str, Sequence[str], None] = '19e4f4905296'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    dialect = op.get_context().dialect.name

    # Drop views to allow table alterations in SQLite
    op.execute("DROP VIEW IF EXISTS v_financial_forecast;")
    op.execute("DROP VIEW IF EXISTS v_goal_progress;")
    op.execute("DROP VIEW IF EXISTS v_assets_liabilities;")
    op.execute("DROP VIEW IF EXISTS v_net_worth;")
    op.execute("DROP VIEW IF EXISTS v_burn_rate;")
    op.execute("DROP VIEW IF EXISTS v_savings_rate;")
    op.execute("DROP VIEW IF EXISTS v_operational_monthly;")
    op.execute("DROP VIEW IF EXISTS v_account_balances;")

    # Drop temporary tables from previous failed runs (SQLite)
    if dialect == 'sqlite':
        op.execute("DROP TABLE IF EXISTS _alembic_tmp_accounts")
        op.execute("DROP TABLE IF EXISTS _alembic_tmp_categories")
        op.execute("DROP TABLE IF EXISTS _alembic_tmp_transactions")
        op.execute("DROP TABLE IF EXISTS _alembic_tmp_recurring_expenses")
        op.execute("DROP TABLE IF EXISTS _alembic_tmp_financial_goals")
        op.execute("DROP TABLE IF EXISTS _alembic_tmp_balance_history")
        op.execute("DROP TABLE IF EXISTS _alembic_tmp_users")

    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('accounts', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)
        batch_op.alter_column('user_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)

    with op.batch_alter_table('balance_history', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)
        batch_op.alter_column('account_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)

    with op.batch_alter_table('categories', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)
        batch_op.alter_column('user_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)
        batch_op.create_unique_constraint('uq_categories_name_user_id', ['name', 'user_id'])

    with op.batch_alter_table('financial_goals', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)
        batch_op.alter_column('user_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)

    with op.batch_alter_table('recurring_expenses', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)
        batch_op.alter_column('category_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)
        batch_op.alter_column('account_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=True)
        batch_op.alter_column('user_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)

    with op.batch_alter_table('transactions', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)
        batch_op.alter_column('category_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=True)
        batch_op.alter_column('transfer_group_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=True)
        batch_op.alter_column('recurring_expense_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=True)
        batch_op.alter_column('account_id',
               existing_type=sa.UUID(),
               existing_nullable=True)
        batch_op.alter_column('user_id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)

    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.NUMERIC(),
               type_=sa.UUID(),
               existing_nullable=False)

    # ### end Alembic commands ###

    # Recreate views
    if dialect == 'postgresql':
        pass
    elif dialect == 'sqlite':
        op.execute("""
        CREATE VIEW v_account_balances AS
        SELECT
            a.id,
            a.user_id,
            a.type,
            a.initial_balance +
            COALESCE(
                SUM(
                    CASE
                        WHEN t.date >= a.initial_balance_date
                         AND t.deleted_at IS NULL
                        THEN t.amount
                        ELSE 0
                    END
                ), 0
            ) AS current_balance
        FROM accounts a
        LEFT JOIN transactions t ON a.id = t.account_id
        GROUP BY
            a.id,
            a.user_id,
            a.type,
            a.initial_balance,
            a.initial_balance_date;
        """)

        op.execute("""
        CREATE VIEW v_operational_monthly AS
        SELECT
            user_id,
            date(date, 'start of month') AS month,
            SUM(CASE WHEN nature = 'INCOME' THEN amount ELSE 0 END) AS total_income,
            SUM(CASE WHEN nature = 'EXPENSE' THEN -amount ELSE 0 END) AS total_expense,
            SUM(
                CASE
                    WHEN nature IN ('INCOME','EXPENSE')
                    THEN amount
                    ELSE 0
                END
            ) AS net_result
        FROM transactions
        WHERE deleted_at IS NULL
        GROUP BY user_id, 2
        ORDER BY user_id, 2;
        """)

        op.execute("""
        CREATE VIEW v_savings_rate AS
        SELECT
            user_id,
            month,
            total_income,
            total_expense,
            net_result,
            CASE
                WHEN total_income > 0
                THEN ROUND(net_result / total_income, 4)
                ELSE 0
            END AS savings_rate
        FROM v_operational_monthly;
        """)

        op.execute("""
        CREATE VIEW v_burn_rate AS
        SELECT
            user_id,
            COALESCE(AVG(total_expense), 0) AS avg_monthly_expense_last_3m
        FROM v_operational_monthly
        WHERE month >= date('now', 'start of month', '-3 months')
          AND month < date('now', 'start of month')
        GROUP BY user_id;
        """)

        op.execute("""
        CREATE VIEW v_net_worth AS
        SELECT
            user_id,
            COALESCE(SUM(current_balance), 0) AS net_worth
        FROM v_account_balances
        GROUP BY user_id;
        """)

        op.execute("""
        CREATE VIEW v_assets_liabilities AS
        SELECT
            user_id,
            CASE
                WHEN type IN ('banco','investimento','carteira','poupanca','outros_ativos')
                    THEN 'asset'
                WHEN type IN ('cartao_credito','outros_passivos')
                    THEN 'liability'
                ELSE 'other'
            END AS classification,
            SUM(
                CASE
                    WHEN type IN ('banco','investimento','carteira','poupanca','outros_ativos')
                        THEN current_balance
                    WHEN type IN ('cartao_credito','outros_passivos')
                        THEN -current_balance
                    ELSE 0
                END
            ) AS total
        FROM v_account_balances
        GROUP BY user_id, classification;
        """)

        op.execute("""
        CREATE VIEW v_goal_progress AS
        SELECT
            g.id,
            g.user_id,
            g.name,
            g.target_amount,
            g.goal_type,
            g.start_date,
            g.target_date,
            nw.net_worth AS current_amount,
            CASE
                WHEN date('now') < g.start_date THEN 0
                WHEN g.target_amount > 0 THEN ROUND((CAST(nw.net_worth AS FLOAT) / CAST(g.target_amount AS FLOAT)) * 100, 2)
                ELSE 0
            END AS percentage_completed,
            CASE WHEN g.target_amount - nw.net_worth > 0 THEN g.target_amount - nw.net_worth ELSE 0 END AS remaining_amount,
            CASE WHEN julianday(g.target_date) - julianday('now', 'start of day') > 0 THEN CAST(julianday(g.target_date) - julianday('now', 'start of day') AS INTEGER) ELSE 0 END AS days_remaining,
            CASE
                WHEN date('now') < g.start_date THEN 1
                WHEN date('now') > g.target_date THEN nw.net_worth >= g.target_amount
                ELSE
                    nw.net_worth >= (
                        g.target_amount * (
                            (julianday('now', 'start of day') - julianday(g.start_date)) /
                            NULLIF((julianday(g.target_date) - julianday(g.start_date)), 0)
                        )
                    )
            END AS on_track
        FROM financial_goals g
        LEFT JOIN v_net_worth nw ON g.user_id = nw.user_id
        WHERE g.deleted_at IS NULL;
        """)

        op.execute("""
        CREATE VIEW v_financial_forecast AS
        WITH stats AS (
            SELECT
                u.id as user_id,
                COALESCE(nw.net_worth, 0) as current_net_worth,
                COALESCE((
                    SELECT AVG(net_result) FROM v_operational_monthly om
                    WHERE om.user_id = u.id
                      AND om.month >= date('now', 'start of month', '-3 months')
                      AND om.month < date('now', 'start of month')
                ), 0) as avg_monthly_result
            FROM users u
            LEFT JOIN v_net_worth nw ON u.id = nw.user_id
        )
        SELECT
            user_id,
            current_net_worth,
            avg_monthly_result as avg_monthly_result_last_3m,
            current_net_worth + (avg_monthly_result * 3) as projected_3m,
            current_net_worth + (avg_monthly_result * 6) as projected_6m,
            current_net_worth + (avg_monthly_result * 12) as projected_12m,
            CASE
                WHEN avg_monthly_result < 0 THEN
                    CASE
                        WHEN current_net_worth <= 0 THEN 0
                        ELSE ABS(CAST(current_net_worth AS FLOAT) / CAST(avg_monthly_result AS FLOAT))
                    END
                ELSE NULL
            END as months_until_zero,
            CASE
                WHEN avg_monthly_result < 0 THEN
                    CASE
                        WHEN current_net_worth <= 0 THEN date('now')
                        ELSE date('now', '+' || CAST(ROUND(ABS(CAST(current_net_worth AS FLOAT) / CAST(avg_monthly_result AS FLOAT))) AS INTEGER) || ' months')
                    END
                ELSE NULL
            END as projected_date_of_zero
        FROM stats;
        """)

def downgrade() -> None:
    pass
